<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式协调与同步</title>
      <link href="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5/"/>
      <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1>分布式互斥</h1><p>分布式系统中排他性的资源访问方式叫作分布式互斥，被互斥访问的共享资源叫作临界资源。</p><h2 id="分布式互斥算法">分布式互斥算法</h2><h3 id="集中式算法">集中式算法</h3><p>通过一个“协调者”——中央服务器来控制程序对临界资源的访问，示意如下图</p><p><img src="%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%92%E6%96%A5-%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%AE%97%E6%B3%95.jpeg" alt="分布式互斥-集中式算法"></p><p>一个程序完成一次临界资源访问，需要如下流程消息交互：</p><ol><li>向协调者发送请求授权信息，1 次消息交互；</li><li>协调者向程序发放授权信息，1 次消息交互；</li><li>程序使用完临界资源后，向协调者发送释放授权，1 次消息交互。</li></ol><h2 id="分布式算法">分布式算法</h2><p>当一个程序需要访问临界资源时，先向系统中的其他程序发送一条请求消息，在接收到所有程序返回的同意消息后，才可访问临界资源。我们把这种算法成为分布式算法，也叫使用组播和逻辑时钟的算法。<br><img src="%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%92%E6%96%A5-%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95.jpeg" alt="分布式互斥-分布式算法"><br>一个程序完成一次临界资源的访问，需要进行如下的信息交互：</p><ol><li><p>向其他 n-1 个程序发送访问临界资源的请求，总共需要 n-1 次消息交互；</p></li><li><p>需要接收到其他 n-1 个程序回复的同意消息，方可访问资源，总共需要 n-1 次消息交互。</p></li></ol><p>在大型系统中使用分布式算法，消息数量会随着需要访问临界资源的程序数量呈指数级增加，容易导致高昂的“沟通成本”。分布式算法适合节点数目少且变动不频繁的系统，且由于每个程序均需通信交互，因此适合 P2P 结构的系统。</p><h2 id="令牌环算法">令牌环算法</h2><p>所有程序构成一个环结构，令牌按照顺时针（或逆时针）方向在程序之间传递，收到令牌的程序有权访问临界资源，访问完成后将令牌传送到下一个程序；若该程序不需要访问临界资源，则直接把令牌传送给下一个程序。</p><p>使用临界资源前，令牌环算法不需要像分布式算法那样挨个征求其他程序的意见了，所以相对而言，在令牌环算法里单个程序具有更高的通信效率。同时，在一个周期内，每个程序都能访问到临界资源。因此令牌环算法的公平性很好，非常适合通信模式为令牌环方式的分布式系统。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式综述</title>
      <link href="/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E8%BF%B0/"/>
      <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1>分布式知识体系</h1><p>分布式相关技术总的来说可以归纳为如下体系结构：<br><img src="knowledgeStructure.jpg" alt="四横四纵知识体系"></p><h1>分布式是什么？</h1><p>分布式是将相同或者相关的程序运行在多台计算机上，从而实现特定目标的一种计算方式。产生分布式的最主要驱动力量，是我们对于性能、可用性及可扩展性的不懈追求。</p><h2 id="发展过程">发展过程</h2><ul><li>单机模式<br>所有业务和数据均部署到同一台机器上。这种模式的好处是功能、代码和数据集中，便于维护、管理和执行，但计算效率是瓶颈。也就是说单机模式性能受限，也存在单点失效的问题。</li><li>数据并行（数据分布式）<br>对数据进行拆分，利用多台计算机并行执行多个相同任务，通过在相同的时间内完成多个相同任务，从而缩短所有任务的总体执行时间，但对提升单个任务的执行性能及降低时延无效。</li><li>任务并行（任务分布式）<br>单任务拆分成多个子任务，多个子任务并行执行，只要一个复杂任务中的任意子任务的执行时间变短了，那么这个业务的整体执行时间也就变短了。该模式在提高性能、扩展性、可维护性等的同时，也带来了设计上的复杂性问题，比如复杂任务的拆分。</li></ul><h2 id="分布式系统的指标">分布式系统的指标</h2><p>分布式的目的是用廉价、普通的机器解决单个计算机处理复杂任务时存在的性能问题、资源瓶颈的问题、可用性和可扩展性问题。用更多机器处理更多的数据和更复杂的任务。所以分布式系统由如下几个重要指标：</p><h3 id="性能指标（Performance）">性能指标（Performance）</h3><p>常见的性能指标，包括吞吐量（Throughput）、响应时间（Response Time）和完成时间（Turnaround Time）</p><ul><li>吞吐量（系统在一定时间内可以处理的任务数）</li></ul><table><thead><tr><th style="text-align:center">指标</th><th style="text-align:left">释义</th></tr></thead><tbody><tr><td style="text-align:center">QPS</td><td style="text-align:left">查询数每秒，用于衡量一个系统每秒处理的查询数。这个指标通常用于读操作，越高说明对读操作的支持越好</td></tr><tr><td style="text-align:center">TPS</td><td style="text-align:left">事务数每秒，用于衡量一个系统每秒处理的事务数。这个指标通常对应写操作，越高说明对写操作的支持越好</td></tr><tr><td style="text-align:center">BPS</td><td style="text-align:left">比特数每秒，用于衡量一个系统每秒处理的数据量。对于一些网络系统、数据管理系统，请求与请求、事务与事务之间也存在着很大的差异，这种情况下BPS 更能客观地反应系统的吞吐量</td></tr></tbody></table><ul><li>响应时间<br>系统响应一个请求或输入需要花费的时间，响应时间直接影响到用户体验，对于时延敏感的业务非常重要</li><li>完成时间<br>系统真正完成一个请求或处理需要花费的时间。任务并行（也叫作任务分布式）模式出现的其中一个目的，就是缩短整个任务的完成时间。特别是需要计算海量数据或处理大规模任务时，用户对完成时间的感受非常明显。</li></ul><h3 id="资源占用（Resource-Usage）">资源占用（Resource Usage）</h3><p>资源占用指的是，一个系统提供正常能力需要占用的硬件资源，比如 CPU、内存、硬盘等。</p><ul><li>一个系统在没有任何负载时的资源占用，叫做空载资源占用，体现了这个系统自身的资源占用情况。</li><li>一个系统满额负载时的资源占用，叫做满载资源占用，体现了这个系统全力运行时占用资源的情况，也体现了系统的处理能力。</li></ul><h3 id="可用性（Availability）">可用性（Availability）</h3><p>系统在面对各种异常时可以正确提供服务的能力。可用性是分布式系统的一项重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。系统的可用性可以用系统停止服务的时间与总的时间之比衡量，还可以用某功能的失败次数与总的请求次数之比来衡量。</p><blockquote><p><strong>可靠性和可用性区别</strong><br>可靠性通常用来表示一个系统完全不出故障的概率，更多地用在硬件领域。而可用性则更多的是指在允许部分组件失效的情况下，一个系统对外仍能正常提供服务的概率。</p></blockquote><h3 id="可扩展性（Scalability）">可扩展性（Scalability）</h3><p>分布式系统通过扩展集群机器规模提高系统性能 (吞吐、响应时间、 完成时间)、存储容量、计算能力的特性，是分布式系统的特有性质。当任务的需求随着具体业务不断提高时，除了升级系统的性能做垂直（纵向）扩展外，另一个做法就是通过增加机器的方式去水平（横向）扩展系统规模。衡量系统可扩展性的常见指标是<strong>加速比（Speedup）</strong>，也就是一个系统进行扩展后相对扩展前的性能提升。</p><h2 id="不同场景下分布式系统的指标">不同场景下分布式系统的指标</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">吞吐量</th><th style="text-align:center">响应时间</th><th style="text-align:center">完成时间</th><th style="text-align:center">资源占用</th><th style="text-align:center">可用性</th><th style="text-align:center">可扩展性</th></tr></thead><tbody><tr><td style="text-align:center">电商系统</td><td style="text-align:center">极高</td><td style="text-align:center">中</td><td style="text-align:center">中</td><td style="text-align:center">高</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">IoT</td><td style="text-align:center">低</td><td style="text-align:center">较短</td><td style="text-align:center">较短</td><td style="text-align:center">较低</td><td style="text-align:center">中</td><td style="text-align:center">中</td></tr><tr><td style="text-align:center">电信业务</td><td style="text-align:center">高</td><td style="text-align:center">短</td><td style="text-align:center">短</td><td style="text-align:center">低</td><td style="text-align:center">极高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">高性能计算机集群</td><td style="text-align:center">较高</td><td style="text-align:center">中</td><td style="text-align:center">极长</td><td style="text-align:center">较高</td><td style="text-align:center">高</td><td style="text-align:center">极高</td></tr><tr><td style="text-align:center">大数据</td><td style="text-align:center">中</td><td style="text-align:center">中</td><td style="text-align:center">长</td><td style="text-align:center">高</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">云计算</td><td style="text-align:center">高</td><td style="text-align:center">中</td><td style="text-align:center">较长</td><td style="text-align:center">较高</td><td style="text-align:center">高</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">区块链</td><td style="text-align:center">低</td><td style="text-align:center">中</td><td style="text-align:center">长</td><td style="text-align:center">高</td><td style="text-align:center">极高</td><td style="text-align:center">低</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS更换Shell为zsh</title>
      <link href="/macOS%20Catalina%20Shell/"/>
      <url>/macOS%20Catalina%20Shell/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac-OS更换Shell为zsh"><a href="#Mac-OS更换Shell为zsh" class="headerlink" title="Mac OS更换Shell为zsh"></a>Mac OS更换Shell为zsh</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在2019年WWDC期间，苹果推出了macOS Catalina，并且将zsh设置为操作系统默认shell。我最近因为新换了Macbook 16 2020，才发现默认shell的变化。<br>更改默认 Shell 的操作步骤：<em><strong>系统偏好设置&gt;用户与群组&gt;高级设置&gt;选择shell程序</strong></em></p><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><p>shell 俗称壳，是用来与 kernel 内核做区分，作用是给计算机使用者提供操作界面，与计算机内核进行交互。它接收用户命令，对命令做解析，然后调用系统中的应用。<br>shell 有很多种，这里介绍几个常见的shell。<br>第一个 Unix Shell 是1979年底在V7 Unix（AT&amp;T第7版）中引入的，以它的资助者 Stephen Bourne 命名。Bourne shell 是一个交互式命令解释器和命令变成语言。<br>Bourne Again Shell （bash）是GNU计划的一部分，用来替代 Bourne shell。现在大多数Linux发行版都适用bash作为默认的shell。</p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>zsh 号称是「终极shell」，从这个称号看出来它的功能应该很强大</p><h4 id="zsh具有以下主要功能："><a href="#zsh具有以下主要功能：" class="headerlink" title="zsh具有以下主要功能："></a>zsh具有以下主要功能：</h4><ul><li>开箱即用、可编程的命令行补全功能可以帮助用户输入各种参数以及选项</li><li>在用户启动的所有shell中共享命令历史。这一点非常棒，曾经因为sh无法很好的解决多个窗口共享历史命令的问题头疼了一阵儿</li><li>通过扩展的文件通配符，可以不利用外部命令达到find命令一般展开文件名</li><li>改进的变量与数组处理</li><li>在缓冲区中编辑多行命令</li><li>多种兼容模式，例如使用/bin/sh运行时可以伪装成Bourne shell</li><li>可以定制呈现形式的提示符；包括在屏幕右端显示信息，并在键入长命令时自动隐藏</li><li>可加载的模块，提供其他各种支持：完整的TCP与Unix域套接字控制，FTP客户端与扩充过的数学函数</li><li>完全可定制化<br>在使用了一段时间的zsh以后，我发现相比bash确实强大不少，但是其配置确实比较麻烦，好在有一个叫做<a href="https://github.com/ohmyzsh/ohmyzsh">oh-my-zsh</a>的zsh配置，十分强大好用<h2 id="oh-my-zs安装与配置"><a href="#oh-my-zs安装与配置" class="headerlink" title="oh-my-zs安装与配置"></a>oh-my-zs安装与配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></li></ul><ol><li>命令安装</li></ol><table><thead><tr><th align="left">Method</th><th align="left">Command</th></tr></thead><tbody><tr><td align="left"><strong>curl</strong></td><td align="left"><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr><tr><td align="left"><strong>wget</strong></td><td align="left"><code>sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr><tr><td align="left"><strong>fetch</strong></td><td align="left"><code>sh -c &quot;$(fetch -o - https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr><tr><td align="left">2. 手动安装</td><td align="left"></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>zsh-autosuggestions 和 zsh-syntax-highlighting 是自定义安装的插件，可以用 git 将插件 clone 到指定插件目录下</p><p>还有一种安装方法是将插件下载下来，将插件文件放入～/.oh-my-zsh/plugins，并且重命名为<strong>插件名.plug.zsh</strong>，最新版的zsh定义了插件名称为&lt;插件名.plug.zsh&gt;，然后在~/.zshrc文件中的plugins属性中加入插件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">    git </span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    incr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="自动提示插件"><a href="#自动提示插件" class="headerlink" title="自动提示插件"></a>自动提示插件</h4><p>  <code>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></p><h4 id="语法高亮插件"><a href="#语法高亮插件" class="headerlink" title="语法高亮插件"></a>语法高亮插件</h4><p>  <code>git clone git://github.com/zsh-users/zsh-syntax-highlighting $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</code></p><h4 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h4><p>  <code>source ~/.zshrc</code></p><p>需要其他插件的可以自行安装，如果插件未安装，开启终端的时候会报错，按照错误提示，安装对应的插件即可。</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> Shell </tag>
            
            <tag> Mac OS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
