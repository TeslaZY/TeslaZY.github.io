<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式协调与同步——分布式锁</title>
      <link href="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式协调与同步——分布式事务</title>
      <link href="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式协调与同步——基本概念与算法</title>
      <link href="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式互斥"><a href="#分布式互斥" class="headerlink" title="分布式互斥"></a>分布式互斥</h1><ul><li>分布式互斥：分布式系统中排他性的资源访问方式</li><li>临界资源：被互斥访问的共享资源</li></ul><p><strong>分布式互斥可通过如下算法实现互斥访问临界资源。</strong></p><h2 id="集中式算法"><a href="#集中式算法" class="headerlink" title="集中式算法"></a>集中式算法</h2><p>通过一个“协调者”——中央服务器来控制程序对临界资源的访问，示意如下图</p><p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%92%E6%96%A5-%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%AE%97%E6%B3%95.jpeg" alt="分布式互斥-集中式算法"></p><p>一个程序完成一次临界资源访问，需要如下流程消息交互：</p><ol><li>向协调者发送请求授权信息，1 次消息交互；</li><li>协调者向程序发放授权信息，1 次消息交互；</li><li>程序使用完临界资源后，向协调者发送释放授权，1 次消息交互。<br>集中式算法的优点在于直观、简单、信息交互量少、易于实现，并且所有程序只需和协调者通信，程序之间无需通信。但是协调者处理的消息数量会随着需要访问临界资源的程序数量线性增加，协调者可能会成为系统的性能瓶颈；另一方面，协调者故障，会导致所有的程序均无法访问临界资源，导致整个系统不可用从而引发单点故障问题。因此，在使用集中式算法的时候，一定要选择性能好、可靠性高的服务器来担任协调者。</li></ol><h2 id="分布式算法"><a href="#分布式算法" class="headerlink" title="分布式算法"></a>分布式算法</h2><p>当一个程序需要访问临界资源时，先向系统中的其他程序发送一条请求消息，在接收到所有程序返回的同意消息后，才可访问临界资源。我们把这种算法成为分布式算法，也叫使用组播和逻辑时钟的算法。<br><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%92%E6%96%A5-%E5%88%86%E5%B8%83%E5%BC%8F%E7%AE%97%E6%B3%95.jpeg" alt="分布式互斥-分布式算法"><br>一个程序完成一次临界资源的访问，需要进行如下的信息交互：</p><ol><li><p>向其他 n-1 个程序发送访问临界资源的请求，总共需要 n-1 次消息交互；</p></li><li><p>需要接收到其他 n-1 个程序回复的同意消息，方可访问资源，总共需要 n-1 次消息交互。</p></li></ol><p>在大型系统中使用分布式算法，消息数量会随着需要访问临界资源的程序数量呈指数级增加，容易导致高昂的“沟通成本”。分布式算法适合节点数目少且变动不频繁的系统，且由于每个程序均需通信交互，因此适合 P2P 结构的系统。</p><h2 id="令牌环算法"><a href="#令牌环算法" class="headerlink" title="令牌环算法"></a>令牌环算法</h2><p>所有程序构成一个环结构，令牌按照顺时针（或逆时针）方向在程序之间传递，收到令牌的程序有权访问临界资源，访问完成后将令牌传送到下一个程序；若该程序不需要访问临界资源，则直接把令牌传送给下一个程序。<br><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%92%E6%96%A5-%E4%BB%A4%E7%89%8C%E7%8E%AF%E7%AE%97%E6%B3%95.jpeg" alt="分布式互斥-令牌环算法"></p><p>使用临界资源前，令牌环算法不需要像分布式算法那样挨个征求其他程序的意见了，所以相对而言，在令牌环算法里单个程序具有更高的通信效率。同时，在一个周期内，每个程序都能访问到临界资源。因此令牌环算法的公平性很好，非常适合通信模式为令牌环方式的分布式系统。</p><hr><h1 id="分布式选举"><a href="#分布式选举" class="headerlink" title="分布式选举"></a>分布式选举</h1><p><strong>集群</strong><br>集群一般是由两个或两个以上的服务器组建而成，每个服务器都是一个节点。<br>分布式集群中负责协调和管理各节点，让各节点协同工作的节点叫做主节点。主节点可以保证其他节点有序运行，但是如果主节点故障集群就会群龙无首，天下大乱。分布式集群中不可一刻无主，当集群中原先的主节点出现故障不能再提供服务时，就要通过“选举”在集群当前的节点中选出一个新的主节点，保证集群的正常运行。</p><h2 id="分布式选举算法"><a href="#分布式选举算法" class="headerlink" title="分布式选举算法"></a>分布式选举算法</h2><h3 id="Bully算法-ID最大的活跃节点"><a href="#Bully算法-ID最大的活跃节点" class="headerlink" title="Bully算法 - ID最大的活跃节点"></a>Bully算法 - ID最大的活跃节点</h3><p>Bully算法会选取所有活着的节点中 ID 最大的节点作为主节点。<br>在 Bully 算法中，节点的角色有两种：普通节点和主节点。初始化时，所有节点都是平等的，都是普通节点，并且都有成为主的权利。但是，当选主成功后，有且仅有一个节点成为主节点，其他所有节点都是普通节点。当且仅当主节点故障或与其他节点失去联系后，才会重新选主。</p><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ul><li>Election 发起选举</li><li>Active 应答Election</li><li>Victory 竞选成功的主节点向其他节点发送竞选成功的消息</li></ul><h4 id="假设条件"><a href="#假设条件" class="headerlink" title="假设条件"></a>假设条件</h4><ul><li>集群中每个节点都知道其他节点的ID</li></ul><h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><ol><li>集群中每个节点判断自己的 ID 是否为当前活着的节点中 ID 最大的，如果是，则直接向其他节点发送 Victory 消息，宣誓自己的主权；</li><li>如果自己不是当前活着的节点中 ID 最大的，则向比自己 ID 大的所有节点发送 Election 消息，并等待其他节点的回复；</li><li>若在给定的时间范围内，本节点没有收到其他节点回复的 Alive 消息，则认为自己成为主节点，并向其他节点发送 Victory 消息，宣誓自己成为主节点；若接收到来自比自己 ID 大的节点的 Alive 消息，则等待其他节点发送 Victory 消息；</li><li>若本节点收到比自己 ID 小的节点发送的 Election 消息，则回复一个 Alive 消息，告知其他节点，我比你大，重新选举。<br><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%89%E4%B8%BE-Bully%E7%AE%97%E6%B3%95.jpeg" alt="分布式选举-Bully算法.jpeg"><blockquote><p><strong>实际应用</strong><br>MongoDB副本集故障转移功能，采用节点的最后操作时间表示ID，时间戳最新并且活着的节点是主节点</p></blockquote></li></ol><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>选举速度快</li><li>算法复杂度低</li><li>简单易实现</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>需要每个节点有全局的节点信息，因此额外信息存储较多；</li><li>任意一个比当前主节点 ID 大的新节点或节点故障后恢复加入集群的时候，都可能会触发重新选举，成为新的主节点，如果该节点频繁退出、加入集群，就会导致频繁切主。</li></ul><h3 id="Raft算法-民主投票"><a href="#Raft算法-民主投票" class="headerlink" title="Raft算法 - 民主投票"></a>Raft算法 - 民主投票</h3><p>Raft 算法是典型的多数派投票选举算法，核心思想是“少数服从多数”，获得投票最多的节点成为主节点。每一轮选举，每个节点只能投一次票。选主行为是周期进行的，包括选主和任值两个时间段，选主阶段对应投票阶段，任值阶段对应节点成为主之后的任期。但也有例外的时候，如果主节点故障，会立马发起选举，重新选出一个主节点。</p><h4 id="名词解释-1"><a href="#名词解释-1" class="headerlink" title="名词解释"></a>名词解释</h4><ul><li>Leader： 主节点，同一时刻只有一个 Leader，负责协调和管理其他节点；</li><li>Candidate： 候选者，每一个节点都可以成为 Candidate，节点在该角色下才可以被选为新的 -Leader；</li><li>Follower ：Leader 的跟随者，不可以发起选举。</li></ul><h4 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h4><ol><li>初始化时，所有节点均为 Follower 状态。</li><li>开始选主时，所有节点的状态由 Follower 转化为 Candidate，并向其他节点发送选举请求。</li><li>其他节点根据接收到的选举请求的先后顺序，回复是否同意成为主。这里需要注意的是，在每一轮选举中，一个节点只能投出一张票。</li><li>若发起选举请求的节点获得超过一半的投票，则成为主节点，其状态转化为 Leader，其他节点的状态则由 Candidate 降为 Follower。Leader 节点与 Follower 节点之间会定期发送心跳包，以检测主节点是否活着。</li><li>当 Leader 节点的任期到了，即发现其他服务器开始下一轮选主周期时，Leader 节点的状态由 Leader 降级为 Follower，进入新一轮选主。<br><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%89%E4%B8%BE-Raft%E7%AE%97%E6%B3%95.jpeg" alt="分布式选举-Raft算法.jpeg"></li></ol><blockquote><p><strong>实际应用</strong><br>Google 开源的 Kubernetes，擅长容器管理与调度，为了保证可靠性，通常会部署 3 个节点用于数据备份（一主两备）。Kubernetes 的选主采用的是开源的 etcd 组件。etcd 的集群管理器 etcds，是一个高可用、强一致性的服务发现存储仓库，就是采用了 Raft 算法来实现选主和一致性的。</p></blockquote><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>选举速度快</li><li>算法复杂度低</li><li>简单易实现</li><li>选举稳定性比 Bully 算法好，当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点获得投票数过半，才会导致切主。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>它要求系统内每个节点都可以相互通信，且需要获得过半的投票数才能选主成功，通信量大</li></ul><h3 id="ZAB算法-有优先级的民主投票"><a href="#ZAB算法-有优先级的民主投票" class="headerlink" title="ZAB算法 - 有优先级的民主投票"></a>ZAB算法 - 有优先级的民主投票</h3><p>ZAB（ZooKeeper Atomic Broadcast）选举算法是为 ZooKeeper 实现分布式协调功能而设计的。相较于 Raft 算法的投票机制，ZAB 算法增加了通过节点 ID 和数据 ID 作为参考进行选主，节点 ID 和数据 ID 越大，表示数据越新，优先成为主。相比较于 Raft 算法，ZAB 算法尽可能保证数据的最新性。ZAB 算法可以说是对 Raft 算法的改进。</p><h4 id="名词解释-2"><a href="#名词解释-2" class="headerlink" title="名词解释"></a>名词解释</h4><h5 id="3种角色"><a href="#3种角色" class="headerlink" title="3种角色"></a>3种角色</h5><ul><li>Leader： 主节点，同一时刻只有一个 Leader，负责协调和管理其他节点；</li><li>Candidate： 候选者，每一个节点都可以成为 Candidate，节点在该角色下才可以被选为新的 -Leader；</li><li>Follower ：Leader 的跟随者，不可以发起选举。</li></ul><h5 id="4个状态"><a href="#4个状态" class="headerlink" title="4个状态"></a>4个状态</h5><ul><li>Looking 状态，即选举状态。当节点处于该状态时，它会认为当前集群中没有 Leader，因此自己进入选举状态。</li><li>Leading 状态，即领导者状态，表示已经选出主，且当前节点为 Leader。</li><li>Following 状态，即跟随者状态，集群中已经选出主后，其他非主节点状态更新为 Following，表示对 Leader 的追随。</li><li>Observing 状态，即观察者状态，表示当前节点为 Observer，持观望态度，没有投票权和选举权。</li></ul><h4 id="节点三元组信息"><a href="#节点三元组信息" class="headerlink" title="节点三元组信息"></a>节点三元组信息</h4><p><strong>(server_id, server_zxID, epoch) =&gt;（本节点的唯一 ID，本节点存放的数据 ID，当前选取轮数）</strong></p><ul><li>server_id表示本节点的唯一 ID</li><li>server_zxID 表示本节点存放的数据 ID，数据 ID 越大表示数据越新，选举权重越大</li><li>epoch 表示当前选取轮数，一般用逻辑时钟表示</li></ul><h4 id="选票信息"><a href="#选票信息" class="headerlink" title="选票信息"></a>选票信息</h4><p>&lt;epoch, vote_id, vote_zxID&gt; =&gt;（当前选取轮数，被投票节点的ID，被投票节点的服务器zxID）</p><ul><li>epoch 表示当前选取轮数</li><li>vote_id 表示被投票节点的 ID</li><li>vote_zxID 表示被投票节点的服务器 zxID</li></ul><h4 id="选主原则"><a href="#选主原则" class="headerlink" title="选主原则"></a>选主原则</h4><p><strong>server_zxID 最大者成为 Leader；若 server_zxID 相同，则 server_id 最大者成为 Leader</strong></p><h4 id="具体流程-1"><a href="#具体流程-1" class="headerlink" title="具体流程"></a>具体流程</h4><p><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%B0%83%E4%B8%8E%E5%90%8C%E6%AD%A5%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%88%86%E5%B8%83%E5%BC%8F%E9%80%89%E4%B8%BE-ZAB%E7%AE%97%E6%B3%95.jpeg" alt="分布式选举-ZAB算法.jpeg"></p><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>算法性能高</li><li>选举稳定性好，当有新节点加入或节点故障恢复后，会触发选主，但不一定会真正切主，除非新节点或故障后恢复的节点数据 ID 和节点 ID 最大，且获得投票数过半，才会导致切主。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>采用广播方式发送信息，若节点中有 n 个节点，每个节点同时广播，则集群中信息量为 n*(n-1) 个消息，容易出现广播风暴；</li><li>除了投票，还增加了对比节点 ID 和数据 ID，这就意味着还需要知道所有节点的 ID 和数据 ID，所以选举时间相对较长</li></ul><blockquote><p>为什么“多数派”选主算法通常采用奇数节点，而不是偶数节点呢？<br>多数派选主算法的核心是少数服从多数，获得投票多的节点胜出。如果采用偶数节点集群，当两个节点均获得一半投票时，无法选出主，必须重新投票选举。但即使重新投票选举，两个节点拥有相同投票数的概率也会很大。因此，多数派选主算法通常采用奇数节点。所以 ZooKeeper、 etcd、Kubernetes 等开源软件选主均采用奇数节点的一个关键原因。 </p></blockquote><hr><h1 id="分布式共识"><a href="#分布式共识" class="headerlink" title="分布式共识"></a>分布式共识</h1><p><strong>分布式共识就是在多个节点均可独自操作或记录的情况下，使得所有节点针对某个状态达成一致的过程。</strong>通过共识机制，我们可以使得分布式系统中的多个节点的数据达成一致。从本质上看，分布式选举问题，其实就是传统的分布式共识方法，主要是基于多数投票策略实现的。</p><h2 id="分布式共识方法"><a href="#分布式共识方法" class="headerlink" title="分布式共识方法"></a>分布式共识方法</h2><blockquote><p>区块链中的一个核心概念：挖矿<br>在传统的交易方式中，用户 A 给用户 B 转账，需要银行来实行具体的转账操作并记录交易，银行会从中收取相应的手续费。而采用分布式在线记账的话，参与记录这笔交易的服务器，也可以从中获得一些奖励。所有服务器帮助记录交易并达成一致的过程，就是区块链中的“挖矿”。区块链是由包含交易信息的区块从后向前有序链接起来的数据结构，其中区块是指很多交易数据的集合，每个区块包括区块头和区块体，区块头包括前一区块的哈希值、本区块的哈希值和时间戳；区块体用来存储交易数据。</p></blockquote><h3 id="PoW-算法"><a href="#PoW-算法" class="headerlink" title="PoW 算法"></a>PoW 算法</h3><blockquote><p>以每个节点或服务器的计算能力（即“算力”）来竞争记账权的机制，因此是一种<strong>使用工作量证明机制的共识算法</strong>。也就是说，谁的计算力强、工作能力强，谁获得记账权的可能性就越大。<br>假设每个节点会划分多个区块用于记录用户交易，PoW 算法获取记账权的原理是：利用区块的 index、前一个区块的哈希值、交易的时间戳、区块数据和 nonce 值，通过 SHA256 哈希算法计算出一个哈希值，并判断前 k 个值是否都为 0。如果不是，则递增 nonce 值，重新按照上述方法计算；如果是，则本次计算的哈希值为要解决的题目的正确答案。谁最先计算出正确答案，谁就获得这个区块的记账权。<br>达成共识的过程，就是获得记账权的节点将该区块信息广播给其他节点，其他节点判断该节点找到的区块中的所有交易都是有效且之前未存在过的，则认为该区块有效，并接受该区块，达成一致。<br>PoW 通过“挖矿”的方式发行新币，把比特币分散给个人，实现了相对的公平。PoW 的容错机制，允许全网 50% 的节点出错，因此，如果要破坏系统，则需要投入极大成本（至少要拥有全球 51% 的算力才可尝试攻击比特币）。但是PoW 机制的缺点很明显，共识达成的周期长、效率低，资源消耗大。<br>PoW 机制每次达成共识需要全网共同参与运算，增加了每个节点的计算量，并且如果题目过难，会导致计算时间长、资源消耗多；而如果题目过于简单，会导致大量节点同时获得记账权，冲突多。这些问题，都会增加达成共识的时间。</p><ul><li>nonce 值是用来找到一个满足哈希值的数字</li><li>k 为哈希值前导零的个数，标记了计算的难度，0 越多计算难度越大。</li></ul></blockquote><h3 id="PoS算法"><a href="#PoS算法" class="headerlink" title="PoS算法"></a>PoS算法</h3><blockquote><p>由系统权益代替算力来决定区块记账权，拥有的权益越大获得记账权的概率就越大。这里所谓的权益，就是每个节点占有货币的数量和时间，而货币就是节点所获得的奖励。PoW 算法充分利用了分布式在线记账中的奖励，鼓励“利滚利”。<br>通过 PoS 算法决定区块记账权的流程和 PoW 算法类似，唯一不同的就是，每个节点在计算自己记账权的时候，通过计算自己的股权或权益来评估，如果发现自己权益最大，则将自己的区块广播给其他节点，当然必须保证该区块的有效性。<br>PoS 不需要消耗大量的电力就能够保证区块链网络的安全性，同时也不需要在每个区块中创建新的货币来激励记账者参与当前网络的运行，这也就在一定程度上缩短了达成共识所需要的时间。所以，基于 PoS 算法的以太坊每秒大概能处理 30 笔左右的交易。但PoS 算法中持币越多或持币越久，币龄就会越高，持币人就越容易挖到区块并得到激励，而持币少的人基本没有机会，这样整个系统的安全性实际上会被持币数量较大的一部分人掌握，容易出现垄断现象。</p></blockquote><h3 id="DPoS算法"><a href="#DPoS算法" class="headerlink" title="DPoS算法"></a>DPoS算法</h3><blockquote><p>为了解决 PoS 算法的垄断问题，2014 年比特股（BitShares）的首席开发者丹尼尔 · 拉里默（Dan Larimer）提出了委托权益证明法，也就是 DPoS 算法。</p><p>DPoS 算法的原理，类似股份制公司的董事会制度，普通股民虽然拥有股权，但进不了董事会，他们可以投票选举代表（受托人）代他们做决策。DPoS 是由被社区选举的可信帐户（受托人，比如得票数排行前 101 位）来拥有记账权。</p><p>为了成为正式受托人，用户要去社区拉票，获得足够多的信任。用户根据自己持有的货币数量占总量的百分比来投票。在 DPos 算法中，通常会选出 k(比如 101) 个受托节点，它们的权利是完全相等的。受托节点之间争取记账权也是根据算力进行竞争的。只要受托节点提供的算力不稳定，计算机宕机或者利用手中的权力作恶，随时可以被握着货币的普通节点投票踢出整个系统，而后备的受托节点可以随时顶上去。</p><p>DPoS 是在 PoW 和 PoS 的基础上进行改进的，相比于 PoS 算法，DPoS 引入了受托人，优点主要表现在：</p><ul><li>由投票选举出的若干信誉度更高的受托人记账，解决了所有节点均参与竞争导致消息量大、达成一致的周期长的问题。也就是说，DPoS 能耗更低，具有更快的交易速度。</li><li>每隔一定周期会调整受托人，避免受托人造假和独权。</li></ul><p>但是，在 DPoS 中，由于大多数持币人通过受托人参与投票，投票的积极性并不高；且一旦出现故障节点，DPoS 无法及时做出应对，导致安全隐患。</p></blockquote><h2 id="一致性与共识的区别是什么？"><a href="#一致性与共识的区别是什么？" class="headerlink" title="一致性与共识的区别是什么？"></a>一致性与共识的区别是什么？</h2><blockquote><p><strong>一致性</strong>：分布式系统中的多个节点之间，给定一系列的操作，在约定协议的保障下，对外界呈现的数据或状态是一致的，一致性强调的是结果。<br><strong>共识</strong>：分布式系统中多个节点之间，彼此对某个状态达成一致结果的过程。共识强调的是达成一致的过程，共识算法是保障系统满足不同程度一致性的核心技术。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式综述</title>
      <link href="/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E8%BF%B0/"/>
      <url>/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式知识体系"><a href="#分布式知识体系" class="headerlink" title="分布式知识体系"></a>分布式知识体系</h1><p>分布式相关技术总的来说可以归纳为如下体系结构：<br><img src="/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%BC%E8%BF%B0/knowledgeStructure.jpg" alt="四横四纵知识体系"></p><h1 id="分布式是什么？"><a href="#分布式是什么？" class="headerlink" title="分布式是什么？"></a>分布式是什么？</h1><p>分布式是将相同或者相关的程序运行在多台计算机上，从而实现特定目标的一种计算方式。产生分布式的最主要驱动力量，是我们对于性能、可用性及可扩展性的不懈追求。  </p><h2 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h2><ul><li>单机模式<br>所有业务和数据均部署到同一台机器上。这种模式的好处是功能、代码和数据集中，便于维护、管理和执行，但计算效率是瓶颈。也就是说单机模式性能受限，也存在单点失效的问题。</li><li>数据并行（数据分布式）<br>对数据进行拆分，利用多台计算机并行执行多个相同任务，通过在相同的时间内完成多个相同任务，从而缩短所有任务的总体执行时间，但对提升单个任务的执行性能及降低时延无效。</li><li>任务并行（任务分布式）<br>单任务拆分成多个子任务，多个子任务并行执行，只要一个复杂任务中的任意子任务的执行时间变短了，那么这个业务的整体执行时间也就变短了。该模式在提高性能、扩展性、可维护性等的同时，也带来了设计上的复杂性问题，比如复杂任务的拆分。  <h2 id="分布式系统的指标"><a href="#分布式系统的指标" class="headerlink" title="分布式系统的指标"></a>分布式系统的指标</h2>分布式的目的是用廉价、普通的机器解决单个计算机处理复杂任务时存在的性能问题、资源瓶颈的问题、可用性和可扩展性问题。用更多机器处理更多的数据和更复杂的任务。所以分布式系统由如下几个重要指标：<h3 id="性能指标（Performance）"><a href="#性能指标（Performance）" class="headerlink" title="性能指标（Performance）"></a>性能指标（Performance）</h3>常见的性能指标，包括吞吐量（Throughput）、响应时间（Response Time）和完成时间（Turnaround Time）</li><li>吞吐量（系统在一定时间内可以处理的任务数）</li></ul><table><thead><tr><th align="center">指标</th><th align="left">释义</th></tr></thead><tbody><tr><td align="center">QPS</td><td align="left">查询数每秒，用于衡量一个系统每秒处理的查询数。这个指标通常用于读操作，越高说明对读操作的支持越好</td></tr><tr><td align="center">TPS</td><td align="left">事务数每秒，用于衡量一个系统每秒处理的事务数。这个指标通常对应写操作，越高说明对写操作的支持越好</td></tr><tr><td align="center">BPS</td><td align="left">比特数每秒，用于衡量一个系统每秒处理的数据量。对于一些网络系统、数据管理系统，请求与请求、事务与事务之间也存在着很大的差异，这种情况下BPS 更能客观地反应系统的吞吐量</td></tr></tbody></table><ul><li>响应时间<br>系统响应一个请求或输入需要花费的时间，响应时间直接影响到用户体验，对于时延敏感的业务非常重要</li><li>完成时间<br>系统真正完成一个请求或处理需要花费的时间。任务并行（也叫作任务分布式）模式出现的其中一个目的，就是缩短整个任务的完成时间。特别是需要计算海量数据或处理大规模任务时，用户对完成时间的感受非常明显。<h3 id="资源占用（Resource-Usage）"><a href="#资源占用（Resource-Usage）" class="headerlink" title="资源占用（Resource Usage）"></a>资源占用（Resource Usage）</h3>资源占用指的是，一个系统提供正常能力需要占用的硬件资源，比如 CPU、内存、硬盘等。</li><li>一个系统在没有任何负载时的资源占用，叫做空载资源占用，体现了这个系统自身的资源占用情况。</li><li>一个系统满额负载时的资源占用，叫做满载资源占用，体现了这个系统全力运行时占用资源的情况，也体现了系统的处理能力。<h3 id="可用性（Availability）"><a href="#可用性（Availability）" class="headerlink" title="可用性（Availability）"></a>可用性（Availability）</h3>系统在面对各种异常时可以正确提供服务的能力。可用性是分布式系统的一项重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。系统的可用性可以用系统停止服务的时间与总的时间之比衡量，还可以用某功能的失败次数与总的请求次数之比来衡量。<blockquote><p><strong>可靠性和可用性区别</strong><br>可靠性通常用来表示一个系统完全不出故障的概率，更多地用在硬件领域。而可用性则更多的是指在允许部分组件失效的情况下，一个系统对外仍能正常提供服务的概率。</p></blockquote><h3 id="可扩展性（Scalability）"><a href="#可扩展性（Scalability）" class="headerlink" title="可扩展性（Scalability）"></a>可扩展性（Scalability）</h3>分布式系统通过扩展集群机器规模提高系统性能 (吞吐、响应时间、 完成时间)、存储容量、计算能力的特性，是分布式系统的特有性质。当任务的需求随着具体业务不断提高时，除了升级系统的性能做垂直（纵向）扩展外，另一个做法就是通过增加机器的方式去水平（横向）扩展系统规模。衡量系统可扩展性的常见指标是<strong>加速比（Speedup）</strong>，也就是一个系统进行扩展后相对扩展前的性能提升。<h2 id="不同场景下分布式系统的指标"><a href="#不同场景下分布式系统的指标" class="headerlink" title="不同场景下分布式系统的指标"></a>不同场景下分布式系统的指标</h2></li></ul><table><thead><tr><th align="center"></th><th align="center">吞吐量</th><th align="center">响应时间</th><th align="center">完成时间</th><th align="center">资源占用</th><th align="center">可用性</th><th align="center">可扩展性</th></tr></thead><tbody><tr><td align="center">电商系统</td><td align="center">极高</td><td align="center">中</td><td align="center">中</td><td align="center">高</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="center">IoT</td><td align="center">低</td><td align="center">较短</td><td align="center">较短</td><td align="center">较低</td><td align="center">中</td><td align="center">中</td></tr><tr><td align="center">电信业务</td><td align="center">高</td><td align="center">短</td><td align="center">短</td><td align="center">低</td><td align="center">极高</td><td align="center">高</td></tr><tr><td align="center">高性能计算机集群</td><td align="center">较高</td><td align="center">中</td><td align="center">极长</td><td align="center">较高</td><td align="center">高</td><td align="center">极高</td></tr><tr><td align="center">大数据</td><td align="center">中</td><td align="center">中</td><td align="center">长</td><td align="center">高</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="center">云计算</td><td align="center">高</td><td align="center">中</td><td align="center">较长</td><td align="center">较高</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="center">区块链</td><td align="center">低</td><td align="center">中</td><td align="center">长</td><td align="center">高</td><td align="center">极高</td><td align="center">低</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac OS更换Shell为zsh</title>
      <link href="/macOS%20Catalina%20Shell/"/>
      <url>/macOS%20Catalina%20Shell/</url>
      
        <content type="html"><![CDATA[<h1 id="Mac-OS更换Shell为zsh"><a href="#Mac-OS更换Shell为zsh" class="headerlink" title="Mac OS更换Shell为zsh"></a>Mac OS更换Shell为zsh</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在2019年WWDC期间，苹果推出了macOS Catalina，并且将zsh设置为操作系统默认shell。我最近因为新换了Macbook 16 2020，才发现默认shell的变化。<br>更改默认 Shell 的操作步骤：<em><strong>系统偏好设置&gt;用户与群组&gt;高级设置&gt;选择shell程序</strong></em></p><h3 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h3><p>shell 俗称壳，是用来与 kernel 内核做区分，作用是给计算机使用者提供操作界面，与计算机内核进行交互。它接收用户命令，对命令做解析，然后调用系统中的应用。<br>shell 有很多种，这里介绍几个常见的shell。<br>第一个 Unix Shell 是1979年底在V7 Unix（AT&amp;T第7版）中引入的，以它的资助者 Stephen Bourne 命名。Bourne shell 是一个交互式命令解释器和命令变成语言。<br>Bourne Again Shell （bash）是GNU计划的一部分，用来替代 Bourne shell。现在大多数Linux发行版都适用bash作为默认的shell。</p><h3 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h3><p>zsh 号称是「终极shell」，从这个称号看出来它的功能应该很强大</p><h4 id="zsh具有以下主要功能："><a href="#zsh具有以下主要功能：" class="headerlink" title="zsh具有以下主要功能："></a>zsh具有以下主要功能：</h4><ul><li>开箱即用、可编程的命令行补全功能可以帮助用户输入各种参数以及选项</li><li>在用户启动的所有shell中共享命令历史。这一点非常棒，曾经因为sh无法很好的解决多个窗口共享历史命令的问题头疼了一阵儿</li><li>通过扩展的文件通配符，可以不利用外部命令达到find命令一般展开文件名</li><li>改进的变量与数组处理</li><li>在缓冲区中编辑多行命令</li><li>多种兼容模式，例如使用/bin/sh运行时可以伪装成Bourne shell</li><li>可以定制呈现形式的提示符；包括在屏幕右端显示信息，并在键入长命令时自动隐藏</li><li>可加载的模块，提供其他各种支持：完整的TCP与Unix域套接字控制，FTP客户端与扩充过的数学函数</li><li>完全可定制化<br>在使用了一段时间的zsh以后，我发现相比bash确实强大不少，但是其配置确实比较麻烦，好在有一个叫做<a href="https://github.com/ohmyzsh/ohmyzsh">oh-my-zsh</a>的zsh配置，十分强大好用<h2 id="oh-my-zs安装与配置"><a href="#oh-my-zs安装与配置" class="headerlink" title="oh-my-zs安装与配置"></a>oh-my-zs安装与配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3></li></ul><ol><li>命令安装</li></ol><table><thead><tr><th align="left">Method</th><th align="left">Command</th></tr></thead><tbody><tr><td align="left"><strong>curl</strong></td><td align="left"><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr><tr><td align="left"><strong>wget</strong></td><td align="left"><code>sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr><tr><td align="left"><strong>fetch</strong></td><td align="left"><code>sh -c &quot;$(fetch -o - https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr><tr><td align="left">2. 手动安装</td><td align="left"></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</span><br><span class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>zsh-autosuggestions 和 zsh-syntax-highlighting 是自定义安装的插件，可以用 git 将插件 clone 到指定插件目录下</p><p>还有一种安装方法是将插件下载下来，将插件文件放入～/.oh-my-zsh/plugins，并且重命名为<strong>插件名.plug.zsh</strong>，最新版的zsh定义了插件名称为&lt;插件名.plug.zsh&gt;，然后在~/.zshrc文件中的plugins属性中加入插件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">    git </span><br><span class="line">    zsh-autosuggestions</span><br><span class="line">    incr</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="自动提示插件"><a href="#自动提示插件" class="headerlink" title="自动提示插件"></a>自动提示插件</h4><p>  <code>git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions</code></p><h4 id="语法高亮插件"><a href="#语法高亮插件" class="headerlink" title="语法高亮插件"></a>语法高亮插件</h4><p>  <code>git clone git://github.com/zsh-users/zsh-syntax-highlighting $ZSH_CUSTOM/plugins/zsh-syntax-highlighting</code></p><h4 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h4><p>  <code>source ~/.zshrc</code></p><p>需要其他插件的可以自行安装，如果插件未安装，开启终端的时候会报错，按照错误提示，安装对应的插件即可。</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> Shell </tag>
            
            <tag> Mac OS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
